<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chain DSL Editor - Prototype</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #1a1a2e; color: #eee; }

    .container { display: flex; height: 100vh; }

    /* Sidebar - Node Palette */
    .sidebar { width: 280px; background: #16213e; padding: 16px; overflow-y: auto; border-right: 1px solid #0f3460; }
    .sidebar h2 { font-size: 14px; color: #888; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }

    .tier { margin-bottom: 24px; }
    .tier-header { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; font-size: 12px; font-weight: 600; }
    .tier-header .dot { width: 8px; height: 8px; border-radius: 50%; }
    .tier-strict .dot { background: #4fc3f7; }
    .tier-inspired .dot { background: #ffb74d; }
    .tier-practical .dot { background: #81c784; }

    .node-item {
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: grab;
      transition: all 0.2s;
    }
    .node-item:hover { border-color: #4fc3f7; transform: translateX(4px); }
    .node-item:active { cursor: grabbing; }
    .node-item .name { font-weight: 600; font-size: 14px; }
    .node-item .desc { font-size: 11px; color: #888; margin-top: 4px; }
    .node-item .sig { font-size: 10px; color: #4fc3f7; font-family: monospace; margin-top: 6px; }

    /* Canvas */
    .canvas-area { flex: 1; display: flex; flex-direction: column; }

    .toolbar {
      background: #16213e;
      padding: 12px 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid #0f3460;
      flex-wrap: wrap;
    }
    .toolbar button {
      background: #0f3460;
      color: #eee;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s;
    }
    .toolbar button:hover { background: #4fc3f7; color: #1a1a2e; }
    .toolbar button.primary { background: #4fc3f7; color: #1a1a2e; }
    .toolbar .spacer { flex: 1; }
    .toolbar .status { font-size: 12px; color: #888; }
    .toolbar .chip {
      background: #0c1a33;
      border: 1px solid #1f3a66;
      color: #9db7ff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .toolbar .chip.active { background: #4fc3f7; color: #0f172a; border-color: #4fc3f7; }
    .toolbar .zoom-group { display: flex; gap: 6px; align-items: center; }
    .toolbar .zoom-label { font-size: 12px; color: #9aa7bd; min-width: 52px; text-align: center; }

    .canvas {
      flex: 1;
      position: relative;
      overflow: hidden;
      touch-action: none;
      background:
        linear-gradient(rgba(79, 195, 247, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(79, 195, 247, 0.05) 1px, transparent 1px);
      background-size: var(--grid-size, 20px) var(--grid-size, 20px);
      background-position: var(--grid-x, 0px) var(--grid-y, 0px);
    }

    .canvas-inner {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: 0 0;
      will-change: transform;
    }

    .canvas svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; overflow: visible; }
    .canvas svg path { stroke: #4fc3f7; stroke-width: 2; fill: none; }
    .canvas svg path.preview { stroke-dasharray: 6 6; opacity: 0.7; }
    .canvas svg path.selected { stroke: #ffb74d; stroke-width: 3; }
    .canvas.pannable { cursor: grab; }
    .canvas.panning { cursor: grabbing; }

    .canvas-node {
      position: absolute;
      background: #16213e;
      border: 2px solid #333;
      border-radius: 12px;
      padding: 16px;
      min-width: 180px;
      cursor: move;
      user-select: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .canvas-node:hover { border-color: #4fc3f7; }
    .canvas-node.selected { border-color: #4fc3f7; box-shadow: 0 0 20px rgba(79, 195, 247, 0.3); }
    .canvas-node.connecting { border-color: #81c784; box-shadow: 0 0 18px rgba(129, 199, 132, 0.35); }
    .canvas-node .node-type { font-size: 10px; color: #4fc3f7; text-transform: uppercase; letter-spacing: 1px; }
    .canvas-node .node-label { font-weight: 600; margin-top: 4px; }
    .canvas-node .node-config { font-size: 11px; color: #888; margin-top: 8px; font-family: monospace; }

    .canvas-node .port {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #333;
      border: 2px solid #4fc3f7;
      border-radius: 50%;
      cursor: crosshair;
    }
    .canvas-node .port-in { top: 50%; left: -6px; transform: translateY(-50%); }
    .canvas-node .port-out { top: 50%; right: -6px; transform: translateY(-50%); }
    .canvas-node .port:hover { background: #4fc3f7; }
    .canvas-node .port.active { background: #81c784; border-color: #81c784; }
    .canvas-node .port.candidate { background: #ffb74d; border-color: #ffb74d; }
    .canvas-node .detail-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #81c784;
      color: #0f3460;
      font-weight: 700;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Output Panel */
    .output-panel {
      width: 400px;
      background: #16213e;
      border-left: 1px solid #0f3460;
      display: flex;
      flex-direction: column;
    }
    .output-panel .tabs {
      display: flex;
      border-bottom: 1px solid #0f3460;
    }
    .output-panel .meta-toggle {
      padding: 8px 16px;
      border-bottom: 1px solid #0f3460;
      font-size: 12px;
      color: #9aa7bd;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .output-panel .meta-toggle input { accent-color: #4fc3f7; }
    .output-panel .tab {
      padding: 12px 20px;
      cursor: pointer;
      font-size: 13px;
      border-bottom: 2px solid transparent;
    }
    .output-panel .tab.active { border-bottom-color: #4fc3f7; color: #4fc3f7; }
    .output-panel .content { flex: 1; overflow: auto; padding: 16px; }

    pre {
      background: #1a1a2e;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.5;
      overflow-x: auto;
    }

    /* Presets */
    .presets { margin-top: 24px; border-top: 1px solid #333; padding-top: 16px; }
    .preset-item {
      background: linear-gradient(135deg, #0f3460, #16213e);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .preset-item:hover { border-color: #81c784; }
    .preset-item .name { font-weight: 600; font-size: 13px; }
    .preset-item .nodes { font-size: 11px; color: #81c784; margin-top: 4px; }
    .preset-item .mini {
      margin-top: 8px;
      background: #0f172a;
      border-radius: 6px;
      border: 1px solid #243b67;
      height: 70px;
      position: relative;
      overflow: hidden;
    }
    .preset-search {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #2a2f3a;
      background: #0f172a;
      color: #cbd5f5;
      font-size: 12px;
      margin-bottom: 12px;
    }

    /* Minimap */
    .minimap {
      position: absolute;
      right: 16px;
      bottom: 16px;
      width: 200px;
      height: 140px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid #2a3b60;
      border-radius: 10px;
      padding: 8px;
      display: none;
      z-index: 10;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }
    .minimap.active { display: block; }
    .minimap canvas { width: 100%; height: 100%; display: block; }

    /* Detail Modal */
    .detail-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 16, 32, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .detail-modal.active { display: flex; }
    .detail-card {
      width: 720px;
      max-width: 90vw;
      background: #0f172a;
      border: 1px solid #243b67;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
    }
    .detail-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #1e2a46;
      font-size: 14px;
      font-weight: 600;
    }
    .detail-header button {
      background: transparent;
      border: none;
      color: #9aa7bd;
      cursor: pointer;
      font-size: 16px;
    }
    .detail-tabs {
      display: flex;
      gap: 8px;
      padding: 10px 16px;
      border-bottom: 1px solid #1e2a46;
    }
    .detail-tab {
      background: #14203a;
      border: 1px solid #243b67;
      color: #9db7ff;
      border-radius: 999px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
    }
    .detail-tab.active { background: #4fc3f7; color: #0f172a; border-color: #4fc3f7; }
    .detail-content {
      padding: 16px;
      max-height: 60vh;
      overflow: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Sidebar -->
    <div class="sidebar">
      <h2>Node Palette</h2>

      <div class="tier tier-strict">
        <div class="tier-header"><span class="dot"></span> Strict Core (CT Laws)</div>
        <div class="node-item" draggable="true" data-type="llm">
          <div class="name">LLM</div>
          <div class="desc">Large Language Model call</div>
          <div class="sig">Single&lt;Text&gt; â†’ Single&lt;Text&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="tool">
          <div class="name">Tool</div>
          <div class="desc">External tool invocation</div>
          <div class="sig">Single&lt;Json&gt; â†’ Single&lt;Json&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="map">
          <div class="name">Map</div>
          <div class="desc">Transform output (Functor)</div>
          <div class="sig">F&lt;A&gt; â†’ F&lt;B&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="bind">
          <div class="name">Bind</div>
          <div class="desc">Dynamic routing (Monad)</div>
          <div class="sig">A â†’ M&lt;B&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="merge">
          <div class="name">Merge</div>
          <div class="desc">Combine results (Monoid)</div>
          <div class="sig">Multi&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
      </div>

      <div class="tier tier-inspired">
        <div class="tier-header"><span class="dot"></span> CT-Inspired</div>
        <div class="node-item" draggable="true" data-type="fallback">
          <div class="name">Fallback</div>
          <div class="desc">Try alternatives on failure</div>
          <div class="sig">Multi&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
      </div>

      <div class="tier tier-practical">
        <div class="tier-header"><span class="dot"></span> Practical</div>
        <div class="node-item" draggable="true" data-type="quorum">
          <div class="name">Quorum</div>
          <div class="desc">N/K consensus</div>
          <div class="sig">Multi&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="gate">
          <div class="name">Gate</div>
          <div class="desc">Conditional branch</div>
          <div class="sig">Single&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="retry">
          <div class="name">Retry</div>
          <div class="desc">Retry on failure</div>
          <div class="sig">Single&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
        <div class="node-item" draggable="true" data-type="loop">
          <div class="name">Loop</div>
          <div class="desc">Goal-driven iteration</div>
          <div class="sig">Single&lt;A&gt; â†’ Single&lt;A&gt;</div>
        </div>
      </div>

      <div class="presets">
        <h2>Presets</h2>
        <input class="preset-search" id="preset-search" placeholder="Search presets..." />
        <div id="preset-list"></div>
      </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-area">
      <div class="toolbar">
        <button onclick="clearCanvas()">Clear</button>
        <button onclick="autoLayout()">Auto Layout</button>
        <button onclick="validateChain()">Validate</button>
        <button onclick="fitToView()">Fit</button>
        <div class="zoom-group">
          <button onclick="zoomOut()">âˆ’</button>
          <span class="zoom-label" id="zoom-label">100%</span>
          <button onclick="zoomIn()">ï¼‹</button>
          <button onclick="resetZoom()">Reset</button>
        </div>
        <button class="chip active" id="toggle-grid">Grid</button>
        <button class="chip active" id="toggle-snap">Snap</button>
        <button class="chip" id="toggle-minimap">Minimap</button>
        <span class="spacer"></span>
        <span class="status" id="status">Ready</span>
        <button class="primary" onclick="runChain()">â–¶ Run</button>
      </div>
      <div class="canvas" id="canvas">
        <div class="canvas-inner" id="canvas-inner">
          <svg id="connections"></svg>
        </div>
        <div class="minimap" id="minimap">
          <canvas id="minimap-canvas" width="200" height="140"></canvas>
        </div>
      </div>
    </div>

    <!-- Output -->
    <div class="output-panel">
      <div class="tabs">
        <div class="tab active" data-tab="mermaid">Mermaid</div>
        <div class="tab" data-tab="json">JSON</div>
        <div class="tab" data-tab="integrity">Integrity</div>
        <div class="tab" data-tab="output">Output</div>
      </div>
      <div class="meta-toggle">
        <input type="checkbox" id="show-meta" />
        <label for="show-meta">Show metadata</label>
      </div>
      <div class="content">
        <pre id="output-content">graph LR
    %% Drag nodes to canvas to build your chain</pre>
      </div>
    </div>
  </div>

  <div class="detail-modal" id="detail-modal">
    <div class="detail-card">
      <div class="detail-header">
        <div id="detail-title">Loop Detail</div>
        <button id="detail-close" aria-label="Close">âœ•</button>
      </div>
      <div class="detail-tabs">
        <button class="detail-tab active" data-detail-tab="summary">Summary</button>
        <button class="detail-tab" data-detail-tab="depth">Depth Dive</button>
      </div>
      <div class="detail-content">
        <pre id="detail-content"></pre>
      </div>
    </div>
  </div>

  <script>
    // State
    const state = {
      nodes: [],
      connections: [],
      selectedNode: null,
      selectedConnection: null,
      dragNode: null,
      dragOffset: { x: 0, y: 0 },
      connecting: null,
      connectingPos: null,
      hoverPort: null,
      detailNode: null,
      detailTab: 'summary',
      showMeta: false,
      lastValidation: null,
      chainFull: null,
      gridSize: 20,
      gridEnabled: true,
      snapEnabled: true,
      minimapEnabled: false,
      minimapDragging: false,
      minimapTransform: null,
      viewport: { x: 40, y: 40, scale: 1 },
      isPanning: false,
      panStart: { x: 0, y: 0 },
      spacePressed: false,
      nodeCounter: 0
    };

    const canvas = document.getElementById('canvas');
    const canvasInner = document.getElementById('canvas-inner');
    const svg = document.getElementById('connections');
    const minimap = document.getElementById('minimap');
    const minimapCanvas = document.getElementById('minimap-canvas');
    const minimapCtx = minimapCanvas.getContext('2d');

    // Presets
    const presets = {
      figma_component: {
        nodes: [
          { id: 'P', type: 'tool', label: 'parse-url', x: 40, y: 170, config: 'Tool:figma_parse_url' },
          { id: 'B', type: 'tool', label: 'bundle', x: 230, y: 170, config: 'Tool:figma_get_node_bundle' },
          { id: 'T', type: 'gate', label: 'target', x: 420, y: 170, config: 'Gate:target(react|html|vue)' },
          { id: 'R', type: 'llm', label: 'react', x: 610, y: 60, config: 'LLM:react-component' },
          { id: 'H', type: 'llm', label: 'html', x: 610, y: 170, config: 'LLM:html-component' },
          { id: 'V', type: 'llm', label: 'vue', x: 610, y: 280, config: 'LLM:vue-component' },
          { id: 'M', type: 'merge', label: 'pick', x: 800, y: 170, config: 'Merge:pick_one' },
          { id: 'G', type: 'gate', label: 'verify?', x: 980, y: 170, config: 'Gate:verify' },
          { id: 'X', type: 'tool', label: 'verify', x: 1160, y: 80, config: 'Tool:figma_verify_visual' },
          { id: 'O', type: 'map', label: 'emit', x: 1160, y: 250, config: 'Map:emit_component,H' },
        ],
        connections: [
          ['P', 'B'],
          ['B', 'T'],
          ['T', 'R'], ['T', 'H'], ['T', 'V'],
          ['R', 'M'], ['H', 'M'], ['V', 'M'],
          ['M', 'G'],
          ['G', 'X'], ['G', 'O'],
          ['X', 'O']
        ],
        chain: {
          id: 'figma_component_router',
          nodes: [
            {
              id: 'router_flow',
              type: 'pipeline',
              nodes: [
                { id: 'router_parse', type: 'tool', name: 'figma:figma_parse_url', args: {} },
                { id: 'router_bundle', type: 'tool', name: 'figma:figma_get_node_bundle', args: { node: '{{router_parse.output}}' } },
                {
                  id: 'router_merge',
                  type: 'merge',
                  strategy: 'first',
                  nodes: [
                    { id: 'router_react', type: 'llm', model: 'codex', prompt: 'React component: {{router_bundle.output}}' },
                    { id: 'router_html', type: 'llm', model: 'claude', prompt: 'HTML component: {{router_bundle.output}}' },
                    { id: 'router_vue', type: 'llm', model: 'gemini', prompt: 'Vue component: {{router_bundle.output}}' }
                  ]
                },
                {
                  id: 'router_gate',
                  type: 'gate',
                  condition: 'verify',
                  then: { id: 'router_verify', type: 'tool', name: 'figma:figma_verify_visual', args: { component: '{{router_merge.output}}' } },
                  else: { id: 'router_emit', type: 'llm', model: 'claude', prompt: 'Emit component: {{router_merge.output}}' }
                }
              ]
            }
          ],
          output: 'router_flow'
        }
      },
      coverage_boost: {
        nodes: [
          { id: 'A', type: 'tool', label: 'source-a', x: 40, y: 80, config: 'Tool:coverage_source (optional)' },
          { id: 'B', type: 'tool', label: 'source-b', x: 40, y: 240, config: 'Tool:coverage_source_alt (optional)' },
          { id: 'F', type: 'fallback', label: 'source', x: 230, y: 160, config: 'Fallback' },
          {
            id: 'L', type: 'loop', label: 'goal', x: 430, y: 160,
            config: 'GoalDriven:coverage:gte:0.85:6',
            detail: {
              summary: 'Iterate until coverage â‰¥ target or max iterations.',
              graph: {
                direction: 'LR',
                nodes: [
                  { id: 'G', type: 'llm', label: 'generate', config: 'LLM:generate_tests' },
                  { id: 'T', type: 'tool', label: 'run-tests', config: 'Tool:run_tests' },
                  { id: 'E', type: 'map', label: 'extract', config: 'Map:extract_coverage_pct,T' },
                  { id: 'C', type: 'gate', label: 'check', config: 'Gate:coverage>=target' }
                ],
                connections: [
                  ['G', 'T'], ['T', 'E'], ['E', 'C'], ['C', 'G']
                ]
              }
            }
          },
          { id: 'R', type: 'tool', label: 'report', x: 660, y: 160, config: 'Tool:report_coverage' },
        ],
        connections: [
          ['A', 'F'], ['B', 'F'],
          ['F', 'L'],
          ['L', 'R']
        ],
        chain: {
          id: 'coverage_boost',
          nodes: [
            {
              id: 'coverage_flow',
              type: 'pipeline',
              nodes: [
                {
                  id: 'coverage_source',
                  type: 'fallback',
                  primary: { id: 'coverage_source_a', type: 'tool', name: 'coverage_source', args: {} },
                  fallbacks: [
                    { id: 'coverage_source_b', type: 'tool', name: 'coverage_source_alt', args: {} }
                  ]
                },
                {
                  id: 'coverage_loop',
                  type: 'goal_driven',
                  goal_metric: 'coverage',
                  goal_operator: 'gte',
                  goal_value: 0.85,
                  action_node: {
                    id: 'coverage_action',
                    type: 'pipeline',
                    nodes: [
                      { id: 'coverage_gen', type: 'llm', model: 'gemini', prompt: 'Generate tests: {{coverage_source.output}}' },
                      { id: 'coverage_run', type: 'tool', name: 'run_tests', args: { suite: '{{coverage_gen.output}}' } }
                    ]
                  },
                  measure_func: 'extract_coverage_pct',
                  max_iterations: 6,
                  strategy_hints: [],
                  conversational: false,
                  relay_models: []
                },
                { id: 'coverage_report', type: 'tool', name: 'report_coverage', args: { from: '{{coverage_loop.output}}' } }
              ]
            }
          ],
          output: 'coverage_flow'
        }
      },
      magi: {
        nodes: [
          { id: 'A', type: 'tool', label: 'read-file', x: 50, y: 150, config: 'Tool:echo' },
          { id: 'B', type: 'llm', label: 'MELCHIOR', x: 280, y: 50, config: 'LLM:codex' },
          { id: 'C', type: 'llm', label: 'BALTHASAR', x: 280, y: 150, config: 'LLM:claude' },
          { id: 'D', type: 'llm', label: 'CASPER', x: 280, y: 250, config: 'LLM:gemini' },
          { id: 'M', type: 'merge', label: 'consensus', x: 510, y: 150, config: 'Merge:concat' },
        ],
        connections: [
          ['A', 'B'], ['A', 'C'], ['A', 'D'],
          ['B', 'M'], ['C', 'M'], ['D', 'M']
        ],
        chain: {
          id: 'magi_review',
          nodes: [
            {
              id: 'magi_flow',
              type: 'pipeline',
              nodes: [
                { id: 'magi_read', type: 'tool', name: 'echo', args: { text: '{{input}}' } },
                {
                  id: 'magi_consensus',
                  type: 'quorum',
                  required: 2,
                  nodes: [
                    { id: 'magi_melchior', type: 'llm', model: 'codex', prompt: 'MELCHIOR review: {{magi_read.output}}' },
                    { id: 'magi_balthasar', type: 'llm', model: 'claude', prompt: 'BALTHASAR review: {{magi_read.output}}' },
                    { id: 'magi_casper', type: 'llm', model: 'gemini', prompt: 'CASPER review: {{magi_read.output}}' }
                  ]
                }
              ]
            }
          ],
          output: 'magi_flow'
        }
      },
      research: {
        nodes: [
          { id: 'Q', type: 'llm', label: 'expand', x: 50, y: 120, config: 'LLM:gemini' },
          { id: 'S1', type: 'llm', label: 'source1', x: 230, y: 50, config: 'LLM:ollama' },
          { id: 'S2', type: 'llm', label: 'source2', x: 230, y: 190, config: 'LLM:ollama' },
          { id: 'F', type: 'llm', label: 'facts', x: 410, y: 120, config: 'LLM:claude' },
          { id: 'V', type: 'llm', label: 'verify', x: 590, y: 50, config: 'LLM:codex' },
          { id: 'C', type: 'llm', label: 'cite', x: 590, y: 190, config: 'LLM:gemini' },
          { id: 'R', type: 'merge', label: 'synthesize', x: 770, y: 120, config: 'Merge:concat' },
        ],
        connections: [
          ['Q', 'S1'], ['Q', 'S2'],
          ['S1', 'F'], ['S2', 'F'],
          ['F', 'V'], ['F', 'C'],
          ['V', 'R'], ['C', 'R']
        ],
        chain: {
          id: 'deep_research',
          nodes: [
            {
              id: 'research_flow',
              type: 'pipeline',
              nodes: [
                { id: 'research_expand', type: 'llm', model: 'gemini', prompt: 'Expand query: {{input}}' },
                {
                  id: 'research_sources',
                  type: 'fanout',
                  nodes: [
                    { id: 'research_source1', type: 'llm', model: 'ollama', prompt: 'Source A: {{research_expand.output}}' },
                    { id: 'research_source2', type: 'llm', model: 'ollama', prompt: 'Source B: {{research_expand.output}}' }
                  ]
                },
                { id: 'research_summarize', type: 'llm', model: 'claude', prompt: 'Summarize: {{research_sources.output}}' },
                {
                  id: 'research_validate',
                  type: 'fanout',
                  nodes: [
                    { id: 'research_verify', type: 'llm', model: 'codex', prompt: 'Verify: {{research_summarize.output}}' },
                    { id: 'research_cite', type: 'llm', model: 'gemini', prompt: 'Cite: {{research_summarize.output}}' }
                  ]
                },
                {
                  id: 'research_merge',
                  type: 'merge',
                  strategy: 'concat',
                  nodes: [
                    { id: 'research_verdict', type: 'llm', model: 'codex', prompt: 'Verdict: {{research_verify.output}}' },
                    { id: 'research_final', type: 'llm', model: 'gemini', prompt: 'Finalize: {{research_cite.output}}' }
                  ]
                }
              ]
            }
          ],
          output: 'research_flow'
        }
      },
      simple: {
        nodes: [
          { id: 'A', type: 'llm', label: 'step1', x: 100, y: 150, config: 'LLM:stub' },
          { id: 'B', type: 'llm', label: 'step2', x: 320, y: 150, config: 'LLM:ollama' },
          { id: 'C', type: 'llm', label: 'step3', x: 540, y: 150, config: 'LLM:ollama' },
        ],
        connections: [['A', 'B'], ['B', 'C']],
        chain: {
          id: 'simple_pipeline',
          nodes: [
            {
              id: 'simple_flow',
              type: 'pipeline',
              nodes: [
                { id: 'simple_a', type: 'llm', model: 'stub', prompt: 'Step1: {{input}}' },
                { id: 'simple_b', type: 'llm', model: 'ollama', prompt: 'Step2: {{simple_a.output}}' },
                { id: 'simple_c', type: 'llm', model: 'ollama', prompt: 'Step3: {{simple_b.output}}' }
              ]
            }
          ],
          output: 'simple_flow'
        }
      },
      'figma-prototype': {
        nodes: [
          { id: 'P', type: 'tool', label: 'parse-url', x: 60, y: 120, config: 'Tool:figma:figma_parse_url' },
          { id: 'F', type: 'tool', label: 'get-file', x: 260, y: 120, config: 'Tool:figma:figma_get_file' },
          { id: 'T', type: 'tool', label: 'tokens', x: 460, y: 40, config: 'Tool:figma:figma_export_tokens' },
          { id: 'S', type: 'llm', label: 'summarize', x: 460, y: 200, config: 'LLM:gemini' },
          { id: 'M', type: 'merge', label: 'merge', x: 660, y: 120, config: 'Merge:concat' },
          { id: 'C', type: 'llm', label: 'compose', x: 860, y: 120, config: 'LLM:claude' },
        ],
        connections: [
          ['P', 'F'],
          ['F', 'T'],
          ['F', 'S'],
          ['T', 'M'],
          ['S', 'M'],
          ['M', 'C']
        ],
        chain: {
          id: 'figma_prototype',
          nodes: [
            {
              id: 'figma_proto_flow',
              type: 'pipeline',
              nodes: [
                { id: 'figma_parse', type: 'tool', name: 'figma:figma_parse_url', args: {} },
                { id: 'figma_file', type: 'tool', name: 'figma:figma_get_file', args: { file: '{{figma_parse.output}}' } },
                {
                  id: 'figma_assets',
                  type: 'fanout',
                  nodes: [
                    { id: 'figma_tokens', type: 'tool', name: 'figma:figma_export_tokens', args: { file: '{{figma_file.output}}' } },
                    { id: 'figma_summary', type: 'llm', model: 'gemini', prompt: 'Summarize design: {{figma_file.output}}' }
                  ]
                },
                { id: 'figma_compose', type: 'llm', model: 'claude', prompt: 'Compose prototype using {{figma_assets.output}}' }
              ]
            }
          ],
          output: 'figma_proto_flow'
        }
      },
      'figma-component': {
        nodes: [
          { id: 'P', type: 'tool', label: 'parse-url', x: 60, y: 120, config: 'Tool:figma:figma_parse_url' },
          { id: 'N', type: 'tool', label: 'get-node', x: 260, y: 120, config: 'Tool:figma:figma_get_node' },
          { id: 'B', type: 'tool', label: 'bundle', x: 460, y: 40, config: 'Tool:figma:figma_get_node_bundle' },
          { id: 'D', type: 'llm', label: 'design', x: 460, y: 200, config: 'LLM:gemini' },
          { id: 'V', type: 'merge', label: 'verify', x: 660, y: 120, config: 'Merge:concat' },
          { id: 'H', type: 'llm', label: 'html', x: 860, y: 120, config: 'LLM:claude' },
        ],
        connections: [
          ['P', 'N'],
          ['N', 'B'],
          ['N', 'D'],
          ['B', 'V'],
          ['D', 'V'],
          ['V', 'H']
        ],
        chain: {
          id: 'figma_web_component',
          nodes: [
            {
              id: 'figma_component_flow',
              type: 'pipeline',
              nodes: [
                { id: 'web_parse', type: 'tool', name: 'figma:figma_parse_url', args: {} },
                { id: 'web_node', type: 'tool', name: 'figma:figma_get_node', args: { node: '{{web_parse.output}}' } },
                {
                  id: 'web_merge',
                  type: 'merge',
                  strategy: 'concat',
                  nodes: [
                    { id: 'web_bundle', type: 'tool', name: 'figma:figma_get_node_bundle', args: { node: '{{web_node.output}}' } },
                    { id: 'web_design', type: 'llm', model: 'gemini', prompt: 'Design notes: {{web_node.output}}' }
                  ]
                },
                { id: 'web_html', type: 'llm', model: 'claude', prompt: 'Web component HTML: {{web_merge.output}}' }
              ]
            }
          ],
          output: 'figma_component_flow'
        }
      }
    };

    const presetMeta = {
      figma_component: { title: 'ðŸŽ¨ Figma â†’ Component (Router)', summary: '10 nodes Â· optional verify', tags: ['figma', 'component'] },
      coverage_boost: { title: 'ðŸ§ª Coverage Boost', summary: '8 nodes Â· numeric coverage', tags: ['coverage', 'loop'] },
      magi: { title: 'ðŸ”® MAGI Code Review', summary: '5 nodes Â· 3-LLM consensus', tags: ['review', 'magi'] },
      research: { title: 'ðŸ” Deep Research', summary: '8 nodes Â· multi-source', tags: ['research'] },
      simple: { title: 'âš¡ Simple Pipeline', summary: '3 nodes Â· Aâ†’Bâ†’C', tags: ['simple'] },
      'figma-prototype': { title: 'ðŸŽ¨ Figma â†’ Prototype', summary: '6 nodes Â· figma-to-prototype', tags: ['figma', 'prototype'] },
      'figma-component': { title: 'ðŸ§© Figma â†’ Web Component', summary: '6 nodes Â· figma-to-web-component', tags: ['figma', 'web'] }
    };

    function renderPresetList(filter = '') {
      const listEl = document.getElementById('preset-list');
      listEl.innerHTML = '';
      const term = filter.trim().toLowerCase();
      Object.entries(presets).forEach(([key, preset]) => {
        const meta = presetMeta[key] || { title: key, summary: `${preset.nodes.length} nodes`, tags: [] };
        const hay = (meta.title + ' ' + meta.summary + ' ' + meta.tags.join(' ')).toLowerCase();
        if (term && !hay.includes(term)) return;
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.preset = key;
        item.innerHTML = `
          <div class="name">${meta.title}</div>
          <div class="nodes">${meta.summary}</div>
          <div class="mini"><svg width="160" height="70"></svg></div>
        `;
        item.addEventListener('click', () => loadPreset(preset));
        listEl.appendChild(item);
        renderPresetMini(item.querySelector('svg'), preset);
      });
    }

    document.getElementById('preset-search').addEventListener('input', e => {
      renderPresetList(e.target.value);
    });

    document.getElementById('toggle-grid').addEventListener('click', e => {
      state.gridEnabled = !state.gridEnabled;
      e.currentTarget.classList.toggle('active', state.gridEnabled);
      updateViewportTransform();
    });

    document.getElementById('toggle-snap').addEventListener('click', e => {
      state.snapEnabled = !state.snapEnabled;
      e.currentTarget.classList.toggle('active', state.snapEnabled);
    });

    document.getElementById('toggle-minimap').addEventListener('click', e => {
      state.minimapEnabled = !state.minimapEnabled;
      e.currentTarget.classList.toggle('active', state.minimapEnabled);
      updateViewportTransform();
    });

    function loadPreset(preset) {
      state.nodes = preset.nodes.map(n => ({ ...n }));
      state.connections = preset.connections.map(c => [...c]);
      state.nodeCounter = state.nodes.length;
      state.lastValidation = null;
      state.chainFull = preset.chain ? JSON.parse(JSON.stringify(preset.chain)) : null;
      clearConnecting();
      closeDetail();
      render();
      fitToView();
      updateOutput();
      setStatus(`Loaded preset with ${state.nodes.length} nodes`);
    }

    // Drag and drop from palette
    document.querySelectorAll('.node-item').forEach(el => {
      el.addEventListener('dragstart', e => {
        e.dataTransfer.setData('type', el.dataset.type);
      });
    });

    canvas.addEventListener('dragover', e => e.preventDefault());
    canvas.addEventListener('drop', e => {
      e.preventDefault();
      const type = e.dataTransfer.getData('type');
      if (type) {
        const world = screenToWorld(e.clientX, e.clientY);
        const id = String.fromCharCode(65 + state.nodeCounter++);
        const position = applySnap({ x: world.x - 90, y: world.y - 40 }, true);
        state.nodes.push({
          id,
          type,
          label: type,
          x: position.x,
          y: position.y,
          config: getDefaultConfig(type),
          detail: type === 'loop' ? defaultLoopDetail() : null
        });
        invalidateChainFull();
        render();
        updateOutput();
      }
    });

    function getDefaultConfig(type) {
      const configs = {
        llm: 'LLM:ollama "prompt"',
        tool: 'Tool:echo "data"',
        merge: 'Merge:concat',
        quorum: 'Quorum:2',
        gate: 'Gate:condition',
        map: 'Map:uppercase,input',
        bind: 'Bind:router',
        fallback: 'Fallback',
        retry: 'Retry:3,1000',
        loop: 'GoalDriven:coverage:gte:0.85:6'
      };
      return configs[type] || type;
    }

    function defaultLoopDetail() {
      return {
        summary: 'Goal-driven loop: generate tests â†’ run â†’ extract coverage â†’ check threshold â†’ iterate.',
        graph: {
          direction: 'LR',
          nodes: [
            { id: 'G', type: 'llm', label: 'generate', config: 'LLM:generate_tests' },
            { id: 'T', type: 'tool', label: 'run-tests', config: 'Tool:run_tests' },
            { id: 'E', type: 'map', label: 'extract', config: 'Map:extract_coverage_pct' },
            { id: 'C', type: 'gate', label: 'check', config: 'Gate:coverage>=target' }
          ],
          connections: [
            ['G', 'T'], ['T', 'E'], ['E', 'C'], ['C', 'G']
          ]
        }
      };
    }

    function updateViewportTransform() {
      const { x, y, scale } = state.viewport;
      canvasInner.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
      const gridSize = state.gridEnabled ? state.gridSize * scale : 100000;
      canvas.style.setProperty('--grid-size', `${gridSize}px`);
      canvas.style.setProperty('--grid-x', `${x}px`);
      canvas.style.setProperty('--grid-y', `${y}px`);
      document.getElementById('zoom-label').textContent = `${Math.round(scale * 100)}%`;
      minimap.classList.toggle('active', state.minimapEnabled);
      renderMinimap();
    }

    function screenToWorld(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (clientX - rect.left - state.viewport.x) / state.viewport.scale,
        y: (clientY - rect.top - state.viewport.y) / state.viewport.scale
      };
    }

    function worldToMinimap(pt, origin, scale) {
      return {
        x: (pt.x - origin.x) * scale,
        y: (pt.y - origin.y) * scale
      };
    }

    function zoomAt(clientX, clientY, deltaScale) {
      const oldScale = state.viewport.scale;
      const newScale = Math.min(2.5, Math.max(0.3, oldScale * deltaScale));
      const world = screenToWorld(clientX, clientY);
      state.viewport.scale = newScale;
      state.viewport.x = clientX - canvas.getBoundingClientRect().left - world.x * newScale;
      state.viewport.y = clientY - canvas.getBoundingClientRect().top - world.y * newScale;
      updateViewportTransform();
      renderConnections();
    }

    function zoomIn() { zoomAt(canvas.getBoundingClientRect().left + 200, canvas.getBoundingClientRect().top + 200, 1.1); }
    function zoomOut() { zoomAt(canvas.getBoundingClientRect().left + 200, canvas.getBoundingClientRect().top + 200, 0.9); }
    function resetZoom() {
      state.viewport = { x: 40, y: 40, scale: 1 };
      updateViewportTransform();
      renderConnections();
    }

    function fitToView() {
      if (state.nodes.length === 0) return;
      const bounds = getNodeBounds();
      const rect = canvas.getBoundingClientRect();
      const padding = 80;
      const width = Math.max(1, bounds.maxX - bounds.minX + padding * 2);
      const height = Math.max(1, bounds.maxY - bounds.minY + padding * 2);
      const scale = Math.min(rect.width / width, rect.height / height);
      state.viewport.scale = Math.min(2.0, Math.max(0.3, scale));
      state.viewport.x = rect.width / 2 - (bounds.minX + (bounds.maxX - bounds.minX) / 2) * state.viewport.scale;
      state.viewport.y = rect.height / 2 - (bounds.minY + (bounds.maxY - bounds.minY) / 2) * state.viewport.scale;
      updateViewportTransform();
      renderConnections();
    }

    function nodeShape(node) {
      const diamondTypes = ['merge', 'quorum', 'gate', 'fallback', 'loop'];
      const subTypes = ['map', 'bind', 'retry'];
      if (diamondTypes.includes(node.type)) return ['{', '}'];
      if (subTypes.includes(node.type)) return ['[[', ']]'];
      return ['[', ']'];
    }

    function applySnap(pos, useGrid = true, size = { w: 180, h: 80 }) {
      let { x, y } = pos;
      if (!state.snapEnabled) return { x, y };
      if (useGrid && state.gridEnabled) {
        x = Math.round(x / state.gridSize) * state.gridSize;
        y = Math.round(y / state.gridSize) * state.gridSize;
      }
      const threshold = 8;
      state.nodes.forEach(n => {
        if (state.dragNode && n.id === state.dragNode.id) return;
        const w = n._w || 180;
        const h = n._h || 80;
        if (Math.abs(x - n.x) < threshold) x = n.x;
        if (Math.abs(y - n.y) < threshold) y = n.y;
        if (Math.abs((x + size.w) - (n.x + w)) < threshold) x = n.x + w - size.w;
        if (Math.abs((y + size.h) - (n.y + h)) < threshold) y = n.y + h - size.h;
        const cx = x + size.w / 2;
        const cy = y + size.h / 2;
        const ncx = n.x + w / 2;
        const ncy = n.y + h / 2;
        if (Math.abs(cx - ncx) < threshold) x = ncx - size.w / 2;
        if (Math.abs(cy - ncy) < threshold) y = ncy - size.h / 2;
      });
      return { x, y };
    }

    function getNodeBounds() {
      if (state.nodes.length === 0) return { minX: 0, minY: 0, maxX: 1, maxY: 1 };
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      state.nodes.forEach(n => {
        const w = n._w || 180;
        const h = n._h || 80;
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + w);
        maxY = Math.max(maxY, n.y + h);
      });
      return { minX, minY, maxX, maxY };
    }

    function renderMinimap() {
      if (!state.minimapEnabled) return;
      const rect = minimapCanvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;
      minimapCanvas.width = w * devicePixelRatio;
      minimapCanvas.height = h * devicePixelRatio;
      minimapCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      minimapCtx.clearRect(0, 0, w, h);

      const bounds = getNodeBounds();
      const pad = 40;
      const bw = Math.max(1, bounds.maxX - bounds.minX + pad * 2);
      const bh = Math.max(1, bounds.maxY - bounds.minY + pad * 2);
      const scale = Math.min(w / bw, h / bh);
      const origin = { x: bounds.minX - pad, y: bounds.minY - pad };
      state.minimapTransform = { origin, scale, width: w, height: h };

      // edges
      minimapCtx.strokeStyle = '#3b82f6';
      minimapCtx.lineWidth = 1;
      state.connections.forEach(([from, to]) => {
        const a = state.nodes.find(n => n.id === from);
        const b = state.nodes.find(n => n.id === to);
        if (!a || !b) return;
        const pa = worldToMinimap({ x: a.x + (a._w || 180), y: a.y + (a._h || 80) / 2 }, origin, scale);
        const pb = worldToMinimap({ x: b.x, y: b.y + (b._h || 80) / 2 }, origin, scale);
        minimapCtx.beginPath();
        minimapCtx.moveTo(pa.x, pa.y);
        minimapCtx.lineTo(pb.x, pb.y);
        minimapCtx.stroke();
      });

      // nodes
      minimapCtx.fillStyle = '#94a3b8';
      state.nodes.forEach(n => {
        const p = worldToMinimap({ x: n.x, y: n.y }, origin, scale);
        const ww = (n._w || 180) * scale;
        const hh = (n._h || 80) * scale;
        minimapCtx.fillRect(p.x, p.y, ww, hh);
      });

      // viewport
      const viewW = canvas.clientWidth / state.viewport.scale;
      const viewH = canvas.clientHeight / state.viewport.scale;
      const viewX = (-state.viewport.x) / state.viewport.scale;
      const viewY = (-state.viewport.y) / state.viewport.scale;
      const vp = worldToMinimap({ x: viewX, y: viewY }, origin, scale);
      minimapCtx.strokeStyle = '#fbbf24';
      minimapCtx.lineWidth = 2;
      minimapCtx.strokeRect(vp.x, vp.y, viewW * scale, viewH * scale);
    }

    function moveViewportToMinimap(e) {
      if (!state.minimapEnabled || !state.minimapTransform) return;
      const rect = minimapCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const { origin, scale } = state.minimapTransform;
      const worldX = x / scale + origin.x;
      const worldY = y / scale + origin.y;
      const canvasRect = canvas.getBoundingClientRect();
      state.viewport.x = canvasRect.width / 2 - worldX * state.viewport.scale;
      state.viewport.y = canvasRect.height / 2 - worldY * state.viewport.scale;
      updateViewportTransform();
      renderConnections();
    }

    function renderPresetMini(svgEl, preset) {
      if (!svgEl) return;
      while (svgEl.firstChild) svgEl.removeChild(svgEl.firstChild);
      const width = 160;
      const height = 70;
      svgEl.setAttribute('viewBox', `0 0 ${width} ${height}`);
      const nodes = preset.nodes || [];
      if (nodes.length === 0) return;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      nodes.forEach(n => {
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + 120);
        maxY = Math.max(maxY, n.y + 60);
      });
      const pad = 10;
      const spanX = Math.max(1, maxX - minX);
      const spanY = Math.max(1, maxY - minY);
      const scale = Math.min((width - pad * 2) / spanX, (height - pad * 2) / spanY);
      const ox = pad - minX * scale;
      const oy = pad - minY * scale;

      const ns = 'http://www.w3.org/2000/svg';
      (preset.connections || []).forEach(([from, to]) => {
        const a = nodes.find(n => n.id === from);
        const b = nodes.find(n => n.id === to);
        if (!a || !b) return;
        const x1 = (a.x + 120) * scale + ox;
        const y1 = (a.y + 30) * scale + oy;
        const x2 = b.x * scale + ox;
        const y2 = (b.y + 30) * scale + oy;
        const path = document.createElementNS(ns, 'path');
        const midX = (x1 + x2) / 2;
        path.setAttribute('d', `M${x1},${y1} L${midX},${y1} L${midX},${y2} L${x2},${y2}`);
        path.setAttribute('stroke', '#4fc3f7');
        path.setAttribute('stroke-width', '1');
        path.setAttribute('fill', 'none');
        svgEl.appendChild(path);
      });

      nodes.forEach(n => {
        const rect = document.createElementNS(ns, 'rect');
        rect.setAttribute('x', n.x * scale + ox);
        rect.setAttribute('y', n.y * scale + oy);
        rect.setAttribute('width', 120 * scale);
        rect.setAttribute('height', 50 * scale);
        rect.setAttribute('rx', 6 * scale);
        rect.setAttribute('fill', '#1f2937');
        rect.setAttribute('stroke', '#334155');
        svgEl.appendChild(rect);
      });
    }

    function generateMermaidForGraph(nodes, connections, direction = 'LR') {
      if (!nodes || nodes.length === 0) return `graph ${direction}\n    %% Empty graph`;

      let mermaid = `graph ${direction}\n`;
      nodes.forEach(node => {
        const [open, close] = nodeShape(node);
        mermaid += `    ${node.id}${open}${node.config}${close}\n`;
      });
      connections.forEach(([from, to]) => {
        mermaid += `    ${from} --> ${to}\n`;
      });
      return mermaid;
    }

    function stripMeta(mermaid) {
      return mermaid
        .split('\n')
        .filter(line => {
          const t = line.trim();
          return !(t.startsWith('%% @chain_full') || t.startsWith('%% @chain_json') ||
                   t.startsWith('%% @chain ') || t.startsWith('%% @node:'));
        })
        .join('\n');
    }

    function openDetail(node) {
      state.detailNode = node;
      state.detailTab = 'summary';
      renderDetail();
      document.getElementById('detail-modal').classList.add('active');
    }

    function closeDetail() {
      document.getElementById('detail-modal').classList.remove('active');
      state.detailNode = null;
    }

    function renderDetail() {
      const node = state.detailNode;
      if (!node || !node.detail) return;
      document.getElementById('detail-title').textContent = `${node.label} (${node.type})`;
      document.querySelectorAll('.detail-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.detailTab === state.detailTab);
      });
      const contentEl = document.getElementById('detail-content');
      if (state.detailTab === 'summary') {
        contentEl.textContent = node.detail.summary || JSON.stringify(node.detail, null, 2);
      } else {
        if (node.detail.graph) {
          const g = node.detail.graph;
          contentEl.textContent = generateMermaidForGraph(g.nodes || [], g.connections || [], g.direction || 'LR');
        } else {
          contentEl.textContent = node.detail.mermaid || JSON.stringify(node.detail, null, 2);
        }
      }
    }

    function setConnecting(nodeId) {
      const fromNode = state.nodes.find(n => n.id === nodeId);
      state.connecting = { from: nodeId };
      if (fromNode) {
        const w = fromNode._w || 180;
        const h = fromNode._h || 80;
        state.connectingPos = { x: fromNode.x + w, y: fromNode.y + h / 2 };
      } else {
        state.connectingPos = null;
      }
    }

    function clearConnecting() {
      state.connecting = null;
      state.connectingPos = null;
      state.hoverPort = null;
    }

    function invalidateChainFull() {
      state.chainFull = null;
    }

    function selectConnection(from, to) {
      state.selectedConnection = { from, to };
      state.selectedNode = null;
      renderConnections();
    }

    function clearSelection() {
      state.selectedNode = null;
      state.selectedConnection = null;
      renderConnections();
    }

    function removeConnection(from, to) {
      state.connections = state.connections.filter(c => !(c[0] === from && c[1] === to));
      state.selectedConnection = null;
      invalidateChainFull();
      updateOutput();
      render();
    }

    function removeNode(nodeId) {
      state.nodes = state.nodes.filter(n => n.id !== nodeId);
      state.connections = state.connections.filter(c => c[0] !== nodeId && c[1] !== nodeId);
      state.selectedNode = null;
      invalidateChainFull();
      updateOutput();
      render();
    }

    function measureNode(el, node) {
      const rect = el.getBoundingClientRect();
      node._w = rect.width / state.viewport.scale;
      node._h = rect.height / state.viewport.scale;
    }

    function render() {
      canvasInner.querySelectorAll('.canvas-node').forEach(el => el.remove());
      const measurements = [];

      state.nodes.forEach(node => {
        const el = document.createElement('div');
        const isConnecting = state.connecting && state.connecting.from === node.id;
        const isCandidate = state.connecting && state.hoverPort && state.hoverPort.nodeId === node.id && state.hoverPort.port === 'in';
        const outClass = isConnecting ? 'port port-out active' : 'port port-out';
        const inClass = isCandidate ? 'port port-in candidate' : 'port port-in';
        const detailBadge = node.detail ? '<div class="detail-badge" data-action="detail">â‹¯</div>' : '';
        el.className = 'canvas-node' + (state.selectedNode === node.id ? ' selected' : '') + (isConnecting ? ' connecting' : '');
        el.style.left = node.x + 'px';
        el.style.top = node.y + 'px';
        el.innerHTML = `
          <div class="${inClass}" data-port="in"></div>
          <div class="node-type">${node.type}</div>
          <div class="node-label">${node.label}</div>
          <div class="node-config">${node.config}</div>
          ${detailBadge}
          <div class="${outClass}" data-port="out"></div>
        `;
        el.dataset.id = node.id;

        el.addEventListener('pointerdown', e => {
          if (e.target.classList.contains('port')) return;
          if (state.spacePressed || e.button === 1) {
            beginPan(e);
            return;
          }
          clearConnecting();
          state.selectedNode = node.id;
          state.selectedConnection = null;
          const world = screenToWorld(e.clientX, e.clientY);
          state.dragNode = node;
          state.dragOffset = { x: world.x - node.x, y: world.y - node.y };
          render();
        });

        el.querySelectorAll('.port').forEach(port => {
          port.addEventListener('pointerenter', () => {
            state.hoverPort = { nodeId: node.id, port: port.dataset.port };
            render();
          });
          port.addEventListener('pointerleave', () => {
            if (state.hoverPort && state.hoverPort.nodeId === node.id && state.hoverPort.port === port.dataset.port) {
              state.hoverPort = null;
              render();
            }
          });
          port.addEventListener('pointerdown', e => {
            e.stopPropagation();
            if (port.dataset.port === 'out') {
              if (state.connecting && state.connecting.from === node.id) {
                clearConnecting();
              } else {
                setConnecting(node.id);
              }
              renderConnections();
            }
          });
        });

        const badge = el.querySelector('.detail-badge');
        if (badge) {
          badge.addEventListener('click', e => {
            e.stopPropagation();
            openDetail(node);
          });
        }
        el.addEventListener('dblclick', e => {
          if (node.detail && !e.target.classList.contains('port')) {
            openDetail(node);
          }
        });

        canvasInner.appendChild(el);
        measurements.push({ el, node });
      });

      measurements.forEach(({ el, node }) => measureNode(el, node));
      renderConnections();
      renderMinimap();
    }

    function updateConnectingPos(clientX, clientY) {
      const world = screenToWorld(clientX, clientY);
      state.connectingPos = { x: world.x, y: world.y };
    }

    function beginPan(e) {
      state.isPanning = true;
      state.panStart = { x: e.clientX, y: e.clientY, ox: state.viewport.x, oy: state.viewport.y };
      canvas.classList.add('panning');
    }

    function endPan() {
      state.isPanning = false;
      canvas.classList.remove('panning');
    }

    document.addEventListener('pointermove', e => {
      if (state.dragNode) {
        const world = screenToWorld(e.clientX, e.clientY);
        const size = { w: state.dragNode._w || 180, h: state.dragNode._h || 80 };
        const snapped = applySnap({ x: world.x - state.dragOffset.x, y: world.y - state.dragOffset.y }, true, size);
        state.dragNode.x = snapped.x;
        state.dragNode.y = snapped.y;
        render();
        updateOutput();
        return;
      }

      if (state.isPanning) {
        const dx = e.clientX - state.panStart.x;
        const dy = e.clientY - state.panStart.y;
        state.viewport.x = state.panStart.ox + dx;
        state.viewport.y = state.panStart.oy + dy;
        updateViewportTransform();
        renderConnections();
        return;
      }

      if (state.minimapDragging) {
        moveViewportToMinimap(e);
        return;
      }

      if (state.connecting) {
        updateConnectingPos(e.clientX, e.clientY);
        renderConnections();
      }
    });

    document.addEventListener('pointerup', () => {
      if (state.dragNode) {
        state.dragNode = null;
        renderMinimap();
      }
      if (state.connecting) {
        if (state.hoverPort && state.hoverPort.port === 'in' && state.hoverPort.nodeId !== state.connecting.from) {
          const exists = state.connections.some(c => c[0] === state.connecting.from && c[1] === state.hoverPort.nodeId);
          if (!exists) {
            state.connections.push([state.connecting.from, state.hoverPort.nodeId]);
            invalidateChainFull();
            updateOutput();
          }
        }
        clearConnecting();
        render();
      }
      if (state.isPanning) endPan();
      if (state.minimapDragging) state.minimapDragging = false;
    });

    canvas.addEventListener('pointerdown', e => {
      if (e.target.closest('.canvas-node')) return;
      clearSelection();
      if (state.spacePressed || e.button === 1) {
        beginPan(e);
      }
    });

    canvas.addEventListener('click', e => {
      if (state.connecting && !e.target.closest('.canvas-node')) {
        clearConnecting();
        render();
      }
    });

    document.addEventListener('keydown', e => {
      if (document.activeElement && document.activeElement.tagName === 'INPUT') return;
      if (e.code === 'Space') {
        state.spacePressed = true;
        canvas.classList.add('pannable');
        e.preventDefault();
      }
      if (e.key === 'Escape' && state.connecting) {
        clearConnecting();
        render();
      }
      if (e.key === 'Escape' && document.getElementById('detail-modal').classList.contains('active')) {
        closeDetail();
      }
      if (e.key === 'Escape') {
        clearSelection();
      }
      if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedConnection) {
        removeConnection(state.selectedConnection.from, state.selectedConnection.to);
      } else if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedNode) {
        removeNode(state.selectedNode);
      }
    });

    document.addEventListener('keyup', e => {
      if (e.code === 'Space') {
        state.spacePressed = false;
        canvas.classList.remove('pannable');
      }
    });

    canvas.addEventListener('wheel', e => {
      if (state.spacePressed || e.ctrlKey || e.metaKey) {
        const delta = e.deltaY < 0 ? 1.08 : 0.92;
        zoomAt(e.clientX, e.clientY, delta);
        e.preventDefault();
        return;
      }
      if (Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) > 0) {
        state.viewport.x -= e.deltaX;
        state.viewport.y -= e.deltaY;
        updateViewportTransform();
        renderConnections();
        e.preventDefault();
      }
    }, { passive: false });

    minimapCanvas.addEventListener('pointerdown', e => {
      if (!state.minimapEnabled) return;
      state.minimapDragging = true;
      moveViewportToMinimap(e);
      e.preventDefault();
    });

    // Render connections
    function renderConnections() {
      while (svg.firstChild) svg.removeChild(svg.firstChild);
      const ns = 'http://www.w3.org/2000/svg';

      function orthoPath(ax, ay, bx, by) {
        const gap = 40;
        if (bx >= ax + gap) {
          const midX = (ax + bx) / 2;
          return `M${ax},${ay} L${midX},${ay} L${midX},${by} L${bx},${by}`;
        }
        const bendX = ax + gap;
        const midY = ay + (by - ay) / 2;
        const backX = bx - gap;
        return `M${ax},${ay} L${bendX},${ay} L${bendX},${midY} L${backX},${midY} L${backX},${by} L${bx},${by}`;
      }

      state.connections.forEach(([fromId, toId]) => {
        const fromNode = state.nodes.find(n => n.id === fromId);
        const toNode = state.nodes.find(n => n.id === toId);
        if (!fromNode || !toNode) return;
        const ax = fromNode.x + (fromNode._w || 180);
        const ay = fromNode.y + (fromNode._h || 80) / 2;
        const bx = toNode.x;
        const by = toNode.y + (toNode._h || 80) / 2;
        const path = document.createElementNS(ns, 'path');
        path.setAttribute('d', orthoPath(ax, ay, bx, by));
        if (state.selectedConnection && state.selectedConnection.from === fromId && state.selectedConnection.to === toId) {
          path.classList.add('selected');
        }
        path.dataset.from = fromId;
        path.dataset.to = toId;
        path.addEventListener('click', e => {
          e.stopPropagation();
          selectConnection(fromId, toId);
        });
        svg.appendChild(path);
      });

      if (state.connecting && state.connectingPos) {
        const fromNode = state.nodes.find(n => n.id === state.connecting.from);
        if (fromNode) {
          const ax = fromNode.x + (fromNode._w || 180);
          const ay = fromNode.y + (fromNode._h || 80) / 2;
          const bx = state.connectingPos.x;
          const by = state.connectingPos.y;
          const preview = document.createElementNS(ns, 'path');
          preview.setAttribute('d', orthoPath(ax, ay, bx, by));
          preview.classList.add('preview');
          svg.appendChild(preview);
        }
      }
    }

    function generateMermaidRaw() {
      const mermaid = generateMermaidForGraph(state.nodes, state.connections, 'LR');
      if (!state.chainFull) return mermaid;
      const fullJson = JSON.stringify(state.chainFull);
      const lines = mermaid.split('\n');
      if (lines.length > 0) {
        lines.splice(1, 0, `    %% @chain_full ${fullJson}`, `    %% @chain_json ${fullJson}`);
      }
      return lines.join('\n');
    }

    // Generate Mermaid (display)
    function generateMermaid() {
      const mermaid = generateMermaidRaw();
      return state.showMeta ? mermaid : stripMeta(mermaid);
    }

    function normalizeChain() {
      const nodes = [...state.nodes].map(n => ({
        id: n.id,
        type: n.type,
        label: n.label,
        config: n.config
      })).sort((a, b) => a.id.localeCompare(b.id));
      const connections = [...state.connections]
        .map(c => [c[0], c[1]])
        .sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));
      return JSON.stringify({ nodes, connections });
    }

    function hashString(str) {
      let hash = 2166136261;
      for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = (hash * 16777619) >>> 0;
      }
      return hash.toString(16).padStart(8, '0');
    }

    function computeIntegrity() {
      const issues = [];
      const warnings = [];
      const nodeIds = state.nodes.map(n => n.id);
      const idSet = new Set(nodeIds);
      const dupIds = nodeIds.filter((id, idx) => nodeIds.indexOf(id) !== idx);
      if (dupIds.length) issues.push(`Duplicate node ids: ${[...new Set(dupIds)].join(', ')}`);

      const dangling = [];
      state.connections.forEach(([from, to]) => {
        if (!idSet.has(from) || !idSet.has(to)) dangling.push(`${from} -> ${to}`);
      });
      if (dangling.length) issues.push(`Dangling edges: ${dangling.join(', ')}`);

      const incoming = {};
      const outgoing = {};
      state.nodes.forEach(n => {
        incoming[n.id] = 0;
        outgoing[n.id] = 0;
      });
      state.connections.forEach(([from, to]) => {
        if (incoming[to] !== undefined) incoming[to] += 1;
        if (outgoing[from] !== undefined) outgoing[from] += 1;
      });

      const outputs = state.nodes.filter(n => outgoing[n.id] === 0);
      const inputs = state.nodes.filter(n => incoming[n.id] === 0);
      const isolated = state.nodes.filter(n => incoming[n.id] === 0 && outgoing[n.id] === 0);

      if (state.nodes.length > 0 && outputs.length === 0) {
        issues.push('No output node (every node has an outgoing edge).');
      }
      if (state.nodes.length > 0 && inputs.length === 0) {
        warnings.push('No input node (every node has an incoming edge).');
      }
      if (isolated.length) warnings.push(`Isolated nodes: ${isolated.map(n => n.id).join(', ')}`);

      // Merge input requirement
      state.nodes.filter(n => n.type === 'merge').forEach(n => {
        const inputsCount = state.connections.filter(c => c[1] === n.id).length;
        if (inputsCount < 2) issues.push(`Merge ${n.id} needs at least 2 inputs (has ${inputsCount})`);
      });

      // Cycle check (informational)
      const visited = new Set();
      const cycleNodes = new Set();
      function hasCycle(nodeId, path = new Set()) {
        if (path.has(nodeId)) return true;
        if (visited.has(nodeId)) return false;
        visited.add(nodeId);
        path.add(nodeId);
        const outgoingEdges = state.connections.filter(c => c[0] === nodeId);
        for (const [, to] of outgoingEdges) {
          if (hasCycle(to, new Set(path))) return true;
        }
        return false;
      }
      state.nodes.forEach(n => {
        if (hasCycle(n.id)) cycleNodes.add(n.id);
      });
      if (cycleNodes.size > 0) warnings.push(`Cycle detected (verify loop semantics): ${[...cycleNodes].join(', ')}`);

      const normalized = normalizeChain();
      const hash = hashString(normalized);
      return {
        status: issues.length === 0 ? 'PASS' : 'FAIL',
        nodeCount: state.nodes.length,
        edgeCount: state.connections.length,
        inputs: inputs.length,
        outputs: outputs.length,
        isolated: isolated.length,
        issues,
        warnings,
        hash
      };
    }

    function renderIntegrity() {
      const report = computeIntegrity();
      const lines = [];
      lines.push(`Integrity: ${report.status}`);
      lines.push(`Nodes: ${report.nodeCount}  Edges: ${report.edgeCount}`);
      lines.push(`Inputs: ${report.inputs}  Outputs: ${report.outputs}  Isolated: ${report.isolated}`);
      lines.push(`Normalized Hash: ${report.hash}`);
      lines.push(`Chain Full: ${state.chainFull ? 'Yes' : 'No'}`);
      if (state.lastValidation) {
        lines.push(`Strict Validation: ${state.lastValidation}`);
      } else {
        lines.push('Strict Validation: (run Validate to check MCP strict mode)');
      }
      if (report.issues.length) {
        lines.push('');
        lines.push('Issues:');
        report.issues.forEach(i => lines.push(`- ${i}`));
      }
      if (report.warnings.length) {
        lines.push('');
        lines.push('Warnings:');
        report.warnings.forEach(w => lines.push(`- ${w}`));
      }
      return lines.join('\n');
    }

    function refreshActiveTab() {
      const content = document.getElementById('output-content');
      const active = document.querySelector('.tab.active');
      if (!active) return;
      switch (active.dataset.tab) {
        case 'mermaid':
          content.textContent = generateMermaid();
          break;
        case 'json':
          content.textContent = JSON.stringify({ nodes: state.nodes, connections: state.connections }, null, 2);
          break;
        case 'integrity':
          content.textContent = renderIntegrity();
          break;
        case 'output':
          content.textContent = state.lastOutput || '(No output yet - click Run)';
          break;
      }
    }

    // Update output
    function updateOutput() {
      refreshActiveTab();
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        refreshActiveTab();
      });
    });

    document.getElementById('show-meta').addEventListener('change', e => {
      state.showMeta = e.target.checked;
      refreshActiveTab();
    });

    // Detail modal interactions
    document.getElementById('detail-close').addEventListener('click', closeDetail);
    document.getElementById('detail-modal').addEventListener('click', e => {
      if (e.target.id === 'detail-modal') closeDetail();
    });
    document.querySelectorAll('.detail-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        state.detailTab = tab.dataset.detailTab;
        renderDetail();
      });
    });

    // Actions
    function clearCanvas() {
      state.nodes = [];
      state.connections = [];
      state.nodeCounter = 0;
      state.lastValidation = null;
      state.chainFull = null;
      clearConnecting();
      closeDetail();
      render();
      updateOutput();
      setStatus('Canvas cleared');
    }

    function autoLayout() {
      // Simple auto-layout
      state.nodes.forEach((node, i) => {
        node.x = 100 + (i % 3) * 220;
        node.y = 80 + Math.floor(i / 3) * 120;
      });
      render();
      updateOutput();
      setStatus('Auto layout applied');
    }

    function validateChainLocal() {
      const errors = [];

      // Check for cycles (simple check)
      const visited = new Set();
      function hasCycle(nodeId, path = new Set()) {
        if (path.has(nodeId)) return true;
        if (visited.has(nodeId)) return false;
        visited.add(nodeId);
        path.add(nodeId);
        const outgoing = state.connections.filter(c => c[0] === nodeId);
        for (const [, to] of outgoing) {
          if (hasCycle(to, new Set(path))) return true;
        }
        return false;
      }

      state.nodes.forEach(n => {
        if (hasCycle(n.id)) errors.push(`Cycle detected involving ${n.id}`);
      });

      // Check merge inputs
      state.nodes.filter(n => n.type === 'merge').forEach(n => {
        const inputs = state.connections.filter(c => c[1] === n.id).length;
        if (inputs < 2) errors.push(`Merge ${n.id} needs at least 2 inputs (has ${inputs})`);
      });

      if (errors.length === 0) {
        state.lastOutput = 'Local validation passed';
        state.lastValidation = 'Local OK';
        setStatus('âœ… Local validation passed');
      } else {
        state.lastOutput = 'Local validation errors:\n- ' + errors.join('\n- ');
        state.lastValidation = `Local FAIL (${errors.length} issues)`;
        setStatus('âŒ Local validation failed');
      }
      document.querySelector('[data-tab="output"]').click();
    }

    async function validateChain() {
      const mermaid = generateMermaidRaw();
      const hasChain = !!state.chainFull;
      setStatus('Validating (strict)...');
      try {
        const res = await fetch('http://localhost:8932/mcp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'tools/call',
            params: {
              name: 'chain.validate',
              arguments: hasChain
                ? { chain: state.chainFull, strict: true }
                : { mermaid, strict: true }
            }
          })
        });

        const text = await res.text();
        const lines = text.split('\n').filter(l => l.startsWith('data:'));
        const data = lines.length > 0
          ? JSON.parse(lines[0].replace('data: ', ''))
          : JSON.parse(text);
        if (data.result && !data.result.isError) {
          const msg = data.result.content?.[0]?.text || 'Validation passed';
          state.lastOutput = msg;
          state.lastValidation = 'Strict OK';
          setStatus('âœ… ' + msg);
        } else {
          const msg = data.result?.content?.[0]?.text || 'Validation failed';
          state.lastOutput = msg;
          state.lastValidation = 'Strict FAIL';
          setStatus('âŒ Validation failed');
        }
        document.querySelector('[data-tab="output"]').click();
      } catch (e) {
        // Fallback to local validation if MCP server is unavailable
        validateChainLocal();
      }
    }

    async function runChain() {
      const mermaid = generateMermaidRaw();
      const hasChain = !!state.chainFull;
      setStatus('Running...');

      try {
        const res = await fetch('http://localhost:8932/mcp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'tools/call',
            params: {
              name: 'chain.run',
              arguments: hasChain
                ? { chain: state.chainFull, timeout: 120 }
                : { mermaid, timeout: 120 }
            }
          })
        });

        const text = await res.text();
        const lines = text.split('\n').filter(l => l.startsWith('data:'));
        const data = lines.length > 0
          ? JSON.parse(lines[0].replace('data: ', ''))
          : JSON.parse(text);
        if (data.result && !data.result.isError) {
          state.lastOutput = data.result.content?.[0]?.text || 'Success (no output)';
          setStatus('âœ… Chain completed');
        } else {
          state.lastOutput = 'Error: ' + (data.result?.content?.[0]?.text || 'Unknown error');
          setStatus('âŒ Chain failed');
        }
      } catch (e) {
        state.lastOutput = 'Error: ' + e.message;
        setStatus('âŒ ' + e.message);
      }

      // Switch to output tab
      document.querySelector('[data-tab="output"]').click();
    }

    function setStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    // Initial render
    renderPresetList();
    updateViewportTransform();
    render();
    updateOutput();
  </script>
</body>
</html>
