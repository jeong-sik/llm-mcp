# Chain Interop Guarantee (Lossless Roundtrip)

This document provides a formal-style guarantee for interoperability between Chain JSON, Mermaid, and Chain DSL.
It is a proof sketch grounded in implementation invariants and tests (not a mechanized proof).

## Definitions

- **Chain JSON**: Canonical source format parsed by `Chain_parser`.
- **Mermaid**: Graph DSL generated by `Chain_mermaid_parser.chain_to_mermaid`.
- **Chain DSL**: Mermaid plus metadata comments used for lossless conversion.

Let:

- `J` be the set of Chain JSON values accepted by `Chain_parser.parse_chain`.
- `M` be the set of Mermaid strings accepted by `Chain_mermaid_parser.parse_mermaid_to_chain`.
- `F : J → M` be `chain_to_mermaid`.
- `G : M → J` be `parse_mermaid_to_chain`.
- `C : J → J` be canonicalization (stable key order + node/edge ordering).

## Preconditions (Assumptions)

1. JSON parsing is deterministic and preserves content for valid inputs.
2. Mermaid comments are preserved end-to-end (no stripping of `%% @chain_full`).
3. `chain_to_mermaid` always embeds the full JSON in Mermaid comments.

## Guarantee Summary

1. **Identity**: `F` embeds full Chain JSON into Mermaid metadata.
2. **Completeness**: `G` prioritizes embedded JSON when present.
3. **Referential Integrity**: Node ids and edge endpoints are preserved verbatim.
4. **Interoperability**: `G ∘ F` is identity on `J`, up to canonical ordering.

## Lemmas

### Lemma 1 (Embedding)

For any `J ∈ J`, `F(J)` produces Mermaid `M` that includes:

```
%% @chain_full { ...J... }
%% @chain_json { ...J... }
```

*Justification*: `chain_to_mermaid` writes both `@chain_full` and `@chain_json` for every emission.

### Lemma 2 (Extraction)

For any Mermaid `M` that contains `%% @chain_full J`, `G(M) = J`.

*Justification*: `parse_mermaid_to_chain` checks metadata and returns `@chain_full` when present, before any inference.

### Lemma 3 (Projection Without Metadata)

If Mermaid contains no `@chain_full`, then `G(M)` is a projection and may be non-isomorphic to the original chain.

*Justification*: Mermaid lacks full schema for Gate/GoalDriven/Fallback/Retry/Subgraph, and placeholders are inserted.

## Theorem (Lossless Roundtrip)

For any `J ∈ J`:

```
G(F(J)) = J
```

*Proof Sketch*:

- By Lemma 1, `F(J)` embeds `@chain_full J` into Mermaid.
- By Lemma 2, `G` returns the embedded JSON.
- Therefore, `G(F(J)) = J`.

## Corollaries

1. **JSON ↔ Mermaid**: `chain.convert` is lossless when `@chain_full` is present.
2. **Mermaid ↔ Chain DSL**: Chain DSL is Mermaid with `@chain_full`; thus lossless.
3. **JSON ↔ Chain DSL**: Immediate from the above.

## Canonical Equality

For test comparisons, use canonicalization:

- Sort nodes by `id`.
- Sort edges by `(from, to)`.
- Use stable key order for JSON.

Then:

```
C(G(F(J))) = C(J)
```

## Complex Constructs (Preserved by Metadata)

- **Loop / Retry / Fallback / GoalDriven**: Preserved via `@chain_full`, not inferred.
- **Recursive / Subgraph / ChainRef**: Preserved via `@chain_full`.
- **Adapters / Tool args / LLM config**: Preserved via `@chain_full`.

## Limitations

- Mermaid without metadata is a *projection*, not a full schema carrier.
- Proof relies on implementation invariants and tests, not mechanized verification.

## Evidence (Tests)

Run:

```bash
dune exec test/test_lossless_roundtrip.exe
```

Tests cover:
- Roundtrip equality (JSON → Mermaid → JSON)
- Complex/nested constructs
- Placeholder elimination when metadata exists

## Mechanized Model (Lean)

See `proofs/chain-interop-lean/` for a Lean 4 mechanized proof of the model:

- `parse (embed c) = c`

This formalizes the metadata-embedding invariant and parser precedence.
  
